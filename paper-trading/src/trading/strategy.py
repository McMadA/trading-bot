"""Trading strategies with pluggable architecture."""

from abc import ABC, abstractmethod
import pandas as pd
from ta.trend import EMAIndicator, SMAIndicator
from ta.momentum import RSIIndicator

from ..data.models import OrderSide

# Default Strategy Parameters
DEFAULT_EMA_PERIOD = 10
DEFAULT_SMA_PERIOD = 20
DEFAULT_RSI_PERIOD = 14
DEFAULT_RSI_OVERBOUGHT = 70
DEFAULT_RSI_OVERSOLD = 30
DEFAULT_ACTIVE_STRATEGY = "ema_sma_crossover"


class Signal:
    """A trading signal generated by a strategy."""

    def __init__(self, symbol: str, side: OrderSide, strength: float = 1.0,
                 reason: str = ""):
        self.symbol = symbol
        self.side = side
        self.strength = strength
        self.reason = reason

    def __repr__(self):
        return f"Signal({self.side.value} {self.symbol}, strength={self.strength}, reason={self.reason})"


class BaseStrategy(ABC):
    """Abstract base strategy. Subclass and implement generate_signals()."""

    def __init__(self, name: str, config: dict):
        self.name = name
        self._config = config

    @abstractmethod
    def generate_signals(self, data: dict, current_positions: dict) -> list:
        """
        Given OHLCV data for all symbols and current positions,
        return a list of Signals (may be empty).

        data: {symbol: DataFrame with [timestamp, open, high, low, close, volume]}
        current_positions: {symbol: Position or None}
        """
        pass

    def calculate_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """Override to add strategy-specific indicators to the DataFrame."""
        return df


class EMASMACrossoverStrategy(BaseStrategy):
    """
    EMA/SMA crossover strategy.
    BUY when EMA crosses above SMA on completed candles.
    SELL when EMA crosses below SMA.
    Ported from v1 Bybit/MEXC bot patterns.
    """

    def __init__(self, config: dict):
        super().__init__("ema_sma_crossover", config)
        self._ema_period = config.get("ema_period", DEFAULT_EMA_PERIOD)
        self._sma_period = config.get("sma_period", DEFAULT_SMA_PERIOD)

    def calculate_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        df = df.copy()
        ema = EMAIndicator(df["close"], window=self._ema_period)
        sma = SMAIndicator(df["close"], window=self._sma_period)
        df["ema"] = ema.ema_indicator()
        df["sma"] = sma.sma_indicator()
        return df

    def generate_signals(self, data, current_positions) -> list:
        signals = []
        for symbol, df in data.items():
            df = self.calculate_indicators(df)

            if len(df) < 3:
                continue

            # Use last two completed candles (skip current incomplete candle)
            last = df.iloc[-2]
            prev = df.iloc[-3]

            if pd.isna(last["ema"]) or pd.isna(last["sma"]):
                continue
            if pd.isna(prev["ema"]) or pd.isna(prev["sma"]):
                continue

            has_position = (
                symbol in current_positions
                and current_positions[symbol] is not None
            )

            # Bullish crossover: EMA was below SMA, now above
            if prev["ema"] < prev["sma"] and last["ema"] > last["sma"]:
                if not has_position:
                    signals.append(Signal(
                        symbol, OrderSide.BUY, 1.0,
                        f"EMA{self._ema_period} crossed above SMA{self._sma_period}"
                    ))

            # Bearish crossover: EMA was above SMA, now below
            elif prev["ema"] > prev["sma"] and last["ema"] < last["sma"]:
                if has_position:
                    signals.append(Signal(
                        symbol, OrderSide.SELL, 1.0,
                        f"EMA{self._ema_period} crossed below SMA{self._sma_period}"
                    ))

        return signals


class RSIStrategy(BaseStrategy):
    """
    RSI-based strategy.
    BUY when RSI crosses up through oversold level.
    SELL when RSI crosses down through overbought level.
    """

    def __init__(self, config: dict):
        super().__init__("rsi", config)
        self._rsi_period = config.get("period", DEFAULT_RSI_PERIOD)
        self._overbought = config.get("overbought", DEFAULT_RSI_OVERBOUGHT)
        self._oversold = config.get("oversold", DEFAULT_RSI_OVERSOLD)

    def calculate_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        df = df.copy()
        rsi = RSIIndicator(df["close"], window=self._rsi_period)
        df["rsi"] = rsi.rsi()
        return df

    def generate_signals(self, data, current_positions) -> list:
        signals = []
        for symbol, df in data.items():
            df = self.calculate_indicators(df)

            if len(df) < 3:
                continue

            last = df.iloc[-2]
            prev = df.iloc[-3]

            if pd.isna(last["rsi"]) or pd.isna(prev["rsi"]):
                continue

            has_position = (
                symbol in current_positions
                and current_positions[symbol] is not None
            )

            # RSI crosses up through oversold — buy signal
            if prev["rsi"] < self._oversold and last["rsi"] >= self._oversold:
                if not has_position:
                    signals.append(Signal(
                        symbol, OrderSide.BUY, 1.0,
                        f"RSI crossed above {self._oversold} (oversold exit)"
                    ))

            # RSI crosses down through overbought — sell signal
            elif prev["rsi"] > self._overbought and last["rsi"] <= self._overbought:
                if has_position:
                    signals.append(Signal(
                        symbol, OrderSide.SELL, 1.0,
                        f"RSI crossed below {self._overbought} (overbought exit)"
                    ))

        return signals


class CombinedStrategy(BaseStrategy):
    """
    Combined EMA/SMA crossover + RSI confirmation.
    BUY: EMA crosses above SMA AND RSI is not overbought.
    SELL: EMA crosses below SMA AND RSI is not oversold.
    """

    def __init__(self, config: dict):
        super().__init__("combined", config)
        self._ema_period = config.get("ema_period", DEFAULT_EMA_PERIOD)
        self._sma_period = config.get("sma_period", DEFAULT_SMA_PERIOD)
        self._rsi_period = config.get("rsi_period", DEFAULT_RSI_PERIOD)
        self._rsi_overbought = config.get("rsi_overbought", DEFAULT_RSI_OVERBOUGHT)
        self._rsi_oversold = config.get("rsi_oversold", DEFAULT_RSI_OVERSOLD)

    def calculate_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        df = df.copy()
        ema = EMAIndicator(df["close"], window=self._ema_period)
        sma = SMAIndicator(df["close"], window=self._sma_period)
        rsi = RSIIndicator(df["close"], window=self._rsi_period)
        df["ema"] = ema.ema_indicator()
        df["sma"] = sma.sma_indicator()
        df["rsi"] = rsi.rsi()
        return df

    def generate_signals(self, data, current_positions) -> list:
        signals = []
        for symbol, df in data.items():
            df = self.calculate_indicators(df)

            if len(df) < 3:
                continue

            last = df.iloc[-2]
            prev = df.iloc[-3]

            required = ["ema", "sma", "rsi"]
            if any(pd.isna(last[c]) or pd.isna(prev[c]) for c in required):
                continue

            has_position = (
                symbol in current_positions
                and current_positions[symbol] is not None
            )

            # Bullish crossover confirmed by RSI not overbought
            if (prev["ema"] < prev["sma"] and last["ema"] > last["sma"]
                    and last["rsi"] < self._rsi_overbought):
                if not has_position:
                    signals.append(Signal(
                        symbol, OrderSide.BUY, 1.0,
                        f"EMA/SMA crossover + RSI={last['rsi']:.1f} (confirmed)"
                    ))

            # Bearish crossover confirmed by RSI not oversold
            elif (prev["ema"] > prev["sma"] and last["ema"] < last["sma"]
                    and last["rsi"] > self._rsi_oversold):
                if has_position:
                    signals.append(Signal(
                        symbol, OrderSide.SELL, 1.0,
                        f"EMA/SMA bearish crossover + RSI={last['rsi']:.1f} (confirmed)"
                    ))

        return signals


def create_strategy(config) -> BaseStrategy:
    """Factory function that creates the strategy specified in config."""
    strategy_name = config.get("strategy.active", DEFAULT_ACTIVE_STRATEGY)
    strategy_config = config.get(f"strategy.{strategy_name}", {})

    strategies = {
        "ema_sma_crossover": EMASMACrossoverStrategy,
        "rsi": RSIStrategy,
        "combined": CombinedStrategy,
    }

    cls = strategies.get(strategy_name)
    if cls is None:
        raise ValueError(f"Unknown strategy: {strategy_name}. "
                         f"Available: {list(strategies.keys())}")
    return cls(strategy_config)
